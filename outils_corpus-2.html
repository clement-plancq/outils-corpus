<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="clement.plancq@ens.psl.eu">
  <title>Outils de corpus – 2</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="files/reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="files/reveal.js/css/theme/mine.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'files/reveal.js/css/print/pdf.css' : 'files/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="files/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Outils de corpus – 2</h1>
  <p class="subtitle">M1 Plurital</p>
  <p class="author">clement.plancq@ens.psl.eu</p>
</section>

<section id="types-tokens-mots" class="slide level3">
<h3>Types / tokens / mots</h3>
<ul>
<li><p>type : forme unique d’un « mot », élément du vocabulaire d’un texte</p></li>
<li><p>token : séquence de caractères délimitée par des séparateurs (« mot graphique »)</p></li>
</ul>
</section>
<section id="types-tokens-mots-1" class="slide level3">
<h3>Types / tokens / mots</h3>
<blockquote>
<p>plus il est facile d’utiliser Amazon et plus Amazon devient puissant et plus il est encore plus facile d’utiliser Amazon<br />
<a href="http://internetactu.blog.lemonde.fr/2018/03/24/la-tyrannie-de-la-commodite/">source</a></p>
</blockquote>
<p>22 tokens, 11 types</p>
<ul>
<li>L’ensemble des types forme le vocabulaire (V) d’un texte ou d’un corpus.<br />
</li>
<li>Le nombre de tokens (N) donnera sa taille.<br />
</li>
<li>Type token ratio (TTR) : <span class="math inline">\(\frac{V}{N} \times 100\)</span> (mesure à n’utiliser que sur des documents de taille comparable) </li>
</ul>
</section>
<section id="types-tokens-mots-2" class="slide level3">
<h3>Types / tokens / mots</h3>
<ul>
<li>Les séparateurs de mots varient selon les langues ; et pour une même langue ils peuvent être ambigus.
<ul>
<li>L’apostrophe en français peut être un séparateur (<em>l’élève</em>) ou non (<em>aujourd’hui</em>).<br />
</li>
<li>Pour résoudre l’ambiguïté on peut utiliser un lexique et/ou des régles comme <code>l’apostrophe suivie d’une voyelle est un séparateur</code></li>
</ul></li>
</ul>
</section>
<section id="types-tokens-mots-3" class="slide level3">
<h3>Types / tokens / mots</h3>
<ul>
  <li>Les séparateurs de mots ne sont pas uniquement utilisés en TAL :
    <ul>
    <li>sélection de mot avec un double clic</li>
    <li>recherche de mot dans une page (« Mots entiers » dans Firefox par exemple)</li>
    <li>correction automatique</li>
    </ul></li>
    <li>Le consortium Unicode a défini ces séparateurs de mot dans l’<a href="http://www.unicode.org/reports/tr29/#Word_Boundaries">annexe #29</a></li>
</ul>
</section>
<section id="types-tokens-mots-4" class="slide level3">
<h3>Types / tokens / mots</h3>
<h4 id="tokens-mots">tokens / mots</h4>
<ul>
<li>mot : unité linguistique, pas de définition unanime chez les linguistes</li>
</ul>
<p>En TAL le mot est le résultat de la segmentation en mots, elle s’appuie sur des choix qui dépendront du type de corpus et de l’application visée.</p>
</section>
<section id="types-tokens-mots-5" class="slide level3">
<h3>Types / tokens / mots</h3>
<h4 id="tokens-mots-1">tokens / mots</h4>
<ul>
<li><p>Un token peut contenir plus d’un mot<br />
<em>zum</em> (all.) -&gt; zu + dem<br />
<em>du</em> (fr.) -&gt; de + le</p></li>
<li><p>Un mot peut être formé de plusieurs tokens<br />
<em>La Rochelle</em> devra être reconnu comme tel par un outil de détection d’entités nommées (NER)<br />
<em>chemin de fer</em> quid des mots composés ?<br />
(voir traitement des mots composés dans le French Treebank (<a href="http://ftb.linguist.univ-paris-diderot.fr/fichiers/public/guide-morphosynt.pdf">guide morpho-syntaxique</a>) )</p></li>
</ul>
</section>
<section id="types-tokens-mots-6" class="slide level3">
<h3>Types / tokens / mots</h3>
<p>Algo de tokenisation de Spacy <a href="https://spacy.io/usage/linguistic-features#tokenization">https://spacy.io/usage/linguistic-features#tokenization</a></p>
<pre><code>  1.  Iterate over whitespace-separated substrings.
  2.  Check whether we have an explicitly defined rule for this substring. If we do, use it.
  3.  Otherwise, try to consume one prefix. If we consumed a prefix, go back to #2, so that special cases always get priority.
  4.  If we didn’t consume a prefix, try to consume a suffix and then go back to #2.
  5.  If we can’t consume a prefix or a suffix, look for a special case.
  6.  Next, look for a token match.
  7.  Look for “infixes” — stuff like hyphens etc. and split the substring into tokens on all infixes.
  8.  Once we can’t consume any more of the string, handle it as a single token.</code></pre>
</section>
<section id="types-tokens-mots-7" class="slide level3">
<h3>Types / tokens / mots</h3>
<p>La tokenisation opérée par Spacy est dite non destructive, c-a-d qu’il est possible de restituer le texte dans sa forme originale après l’opération de tokenisation.</p>
<p>Dans les corpus UD on trouve le texte original en commentaire</p>
<pre><code># sent_id = annodis.er_00190
# text = &quot;Verdun, ville de lumière !&quot;
1   &quot;   &quot;   PUNCT   _   _   2   punct   _   SpaceAfter=No
2   Verdun  Verdun  PROPN   _   Gender=Masc|Number=Sing 0   root    _   SpaceAfter=No
3   ,   ,   PUNCT   _   _   2   punct   _   _
4   ville   ville   NOUN    _   Gender=Fem|Number=Sing  2   appos   _   _
5   de  de  ADP _   _   6   case    _   _
6   lumière lumière NOUN    _   Gender=Fem|Number=Sing  4   nmod    _   _
7   !   !   PUNCT   _   _   2   punct   _   SpaceAfter=No
8   &quot;   &quot;   PUNCT   _   _   2   punct   _   _</code></pre>
<p><a href="https://github.com/UniversalDependencies/UD_French-Sequoia/blob/master/fr_sequoia-ud-dev.conllu">source</a></p>
</section>
<section id="types-tokens-mots-8" class="slide level3">
<h3>Types / tokens / mots</h3>
<h4 id="subtoken-tokenization">subtoken tokenization</h4>
<p>Les derniers développements en <em>machine learning</em> utilisent une tokenisation au niveau des « sous-tokens » (<em>subtoken</em>)</p>
<p>Un des objectifs de cette approche est de limiter la taille du vocabulaire (V) des très gros corpus.</p>
<pre><code>low    -&gt; low
lower  -&gt; low #er
lowest -&gt; low #est</code></pre>
<p>Voir ce notebook Hugging Face : <a href="https://github.com/huggingface/transformers/blob/master/notebooks/01-training-tokenizers.ipynb">https://github.com/huggingface/transformers/blob/master/notebooks/01-training-tokenizers.ipynb</a></p>
</section>
<section id="types-tokens-mots-9" class="slide level3">
<h3>Types / tokens / mots</h3>
<h4 id="normalisation-unicode">Normalisation Unicode</h4>
<p>La tokenisation est souvent précédée d’une étape de normalisation des caractères</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="im">import</span> unicodedata</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">[c <span class="cf">for</span> c <span class="kw">in</span> unicodedata.normalize(<span class="st">&#39;NFC&#39;</span>, <span class="st">&#39;Ô&#39;</span>)]</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">[<span class="st">&#39;Ô&#39;</span>]</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">[c <span class="cf">for</span> c <span class="kw">in</span> unicodedata.normalize(<span class="st">&#39;NFD&#39;</span>, <span class="st">&#39;Ô&#39;</span>)]</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">[<span class="st">&#39;O&#39;</span>, <span class="st">&#39;̂ &#39;</span>]</a></code></pre></div>
<p>Voir <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize">https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize</a> et <a href="https://unicode.org/reports/tr15/#Norm_Forms">https://unicode.org/reports/tr15/#Norm_Forms</a></p>
</section>
<section class="slide level3">

<h4 id="morphologie">Morphologie</h4>
<p>La morphologie est l’étude de la formation des mots et de leurs variations. Les outils de TAL s’intéressent essentiellement à l’analyse morphologique.</p>
</section>
<section class="slide level3">

<h4 id="morphologie-1">Morphologie</h4>
<p>On distingue deux familles de procédés morphologiques :</p>
<ol type="1">
<li><p>la flexion : forme canonique (lemme), formes fléchies</p>
<p><em>porter, portes, porteras, …</em><br />
<em>journal, journeaux</em><br />
<em>grand, grande, grands, grandes, …</em></p></li>
<li><p>la dérivation : base + affixe -&gt; dérivé</p>
<p><em>réaliser / V + able -&gt; réalisable / A</em><br />
<em>ir + réalisable / A -&gt; irréalisable / A</em><br />
<small>∃ d’autres procédés de dérivation<br />
(conversion, troncation, composition, …)</small></p></li>
</ol>
</section>
<section id="stemming-racinisation" class="slide level3">
<h3><em>stemming</em> (racinisation)</h3>
<!--
| **mot**   | **racine** |
|:---------------:|:------------:|
| Contournant   | contourn   |
| Contourne | contourn   |
| Contours  | contour    |
-->
<p>La racinisation consiste à supprimmer d’un mot les suffixes et/ou préfixes pour obtenir son radical ou sa racine.</p>
<p>La racine produite n’est pas une unité du lexique</p>
<p>Le <em>stemming</em> est principalement utilisé en recherche d’information (inclus dans Lucene, Elastisearch). C’est un traitement rapide qui permet d’améliorer le rappel</p>
<p>Voir la <a href="http://snowballstem.org/demo.html">démo de Snowball</a></p>
</section>
<section id="stemming-racinisation-1" class="slide level3">
<h3><em>stemming</em> (racinisation)</h3>
<p>∃ différents algorithmes de <em>stemming</em>.</p>
<p>Ils fonctionnent à l’aide de succession de règles de désuffixation à base d’alternances <em>C</em> <em>V</em> et d’une liste de suffixes propres à chaque langue.</p>
<p>La longueur du suffixe peut déterminer quelle est la règle à appliquer.</p>
<p>Pour le français les algos incluent des règles de recodage des terminaisons de suffixe</p>
<p><em>abandonneras</em> -&gt; <em>abandonn</em> <small>(2b)</small> -&gt; <em>abandon</em> <small>(step5)</small></p>
<p>Voir l’<a href="http://snowball.tartarus.org/algorithms/french/stemmer.html">algo de Snowball pour le français</a></p>
</section>
<section id="lemmatisation" class="slide level3">
<h3>Lemmatisation</h3>
<p>Trouve le lemme à partir d’une forme fléchie accompagnée ou non de sa catégorie grammaticale</p>
<p>Lemmatiseur avec base de données lexicales / lemmatiseur par règles</p>
<ul>
<li><p>Les premiers utilisent des lexiques de formes fléchies (<a href="http://alpage.inria.fr/~sagot/lefff.html">lefff</a>, <a href="http://infolingu.univ-mlv.fr/DonneesLinguistiques/Dictionnaires/delas.html">DELAF</a>).</p></li>
<li><p>Les seconds incluent une analyse morphologique. Ils ont l’avantage de pouvoir prendre en compte les néologismes.<br />
Pour le français : <a href="http://www.cnrtl.fr/outils/flemm/">Flemm</a> de F. Namer</p></li>
</ul>
</section>
<section id="flemm" class="slide level3">
<h3>Flemm</h3>
<p>(Repris de P. Zweigenbaum)</p>
<ul>
<li><p>Étant donné un mot et sa catégorie syntaxique <em>mot</em> + CAT<br />
(formats : TreeTagger/fr ou Brill/INaLF)</p></li>
<li><p>Calcule le lemme de ce mot (et raffine la catégorie) <em>mot</em> + CAT:tt + lemme <em>curieuse</em> ADJ -&gt; <em>curieuse</em> ADJ:A-fs- <em>curieux</em></p></li>
<li><p>Fonctionne sur des mots inconnus :<br />
<em>schtroumpfiennes</em> ADJ -&gt; <em>schtroumpfiennes</em> ADJ:A-fp- <em>schtroumpfien</em></p></li>
</ul>
</section>
<section id="flemm-1" class="slide level3">
<h3>Flemm</h3>
<h4 id="analyse-linguistique-le-cas-de--erent">Analyse linguistique : le cas de <em>-èrent</em></h4>
<ol type="1">
<li><p>en général, <em>-èrent</em> marque les verbes du 3ème groupe au passé simple : <em>céd-èrent</em></p></li>
<li><p>quelquefois, la terminaison est plus courte et <em>-èrent</em> marque le présent : <em>légifèr-ent</em></p></li>
<li><p>très rarement,terminaison ambiguë : <em>lac-èrent</em> et <em>lacèr-ent</em></p></li>
</ol>
</section>
<section id="flemm-2" class="slide level3">
<h3>Flemm</h3>
<h4 id="regles-et-exceptions-le-cas-de--erent">Règles et exceptions : le cas de <em>-èrent</em></h4>
<ol start="3" type="1">
<li><p>les partitions ambiguës sont lexicalisées car rares</p></li>
<li><p>la règle étant le désuffixage sur le suffixe le plus long, les verbes correspondant au suffixe <em>-ent</em> tels que <em>légifèr-</em> sont lexicalisés</p></li>
<li><p>autres cas (e.g. <em>céd-</em> ) : désuffixage régulier sur <em>-èrent</em>.</p></li>
</ol>
</section>
<section id="flemm-3" class="slide level3">
<h3>Flemm</h3>
<h4 id="reduction-des-allomorphes">Réduction des allomorphes</h4>
<p>Principe : réduction à une racine unique<br />
<em>cèd-</em> -&gt; <em>céd-</em><br />
<em>jett-</em> -&gt; <em>jet-</em></p>
<h4 id="regles-et-exceptions-le-cas-de-tt-">Règles et exceptions : le cas de <em>tt-</em></h4>
<ol type="1">
<li><p>26 lemmes ont leur racine qui se termine par <em>tt-</em><br />
<em>guetter</em></p></li>
<li><p>pour les autres, la consonne géminée est simplifiée<br />
<em>jeter</em></p></li>
</ol>
</section>
<section id="analyseur-derivationnel-derif" class="slide level3">
<h3>Analyseur dérivationnel : DériF</h3>
<p>(Repris de P. Zweigenbaum)</p>
<ul>
<li><p>Étant donné un lemme et sa catégorie syntaxique <em>sympathique/ADJ</em></p></li>
<li><p>Analyse la construction de ce lemme<br />
[ [<em>sympathie NOM</em>] <em>ique ADJ</em>] (<em>sympathique/ADJ</em>, <em>sympathie/NOM</em>) “En rapport avec le(s) sympathie”</p></li>
<li><p>Analyse récursive, produit l’arbre de construction du mot</p></li>
</ul>
</section>
<section id="analyseur-derivationnel-derif-1" class="slide level3">
<h3>Analyseur dérivationnel : DériF</h3>
<p>(Repris de P. Zweigenbaum)</p>
<h4 id="example-impensableadj">Example (<em>impensable/ADJ</em>)</h4>
<p><em>ADJ/in/pre/ADJ</em> + <em>pensable/ADJ</em>, <em>VERBE/able/suf/ADJ</em> + <em>penser/VERBE</em> “Non pensable”</p>
<p>A besoin en général de connaître la base du mot (<em>sympathie/NOM</em>, <em>penser/VERBE</em>)</p>
</section>
<section id="analyseur-derivationnel-derif-2" class="slide level3">
<h3>Analyseur dérivationnel : DériF</h3>
<h4 id="regles-de-formation-de-mots">Règles de formation de mots</h4>
<p>déXiser V [dé [X’ N] + iser V]<br />
Xable A [[X’ (er) V] + able A]<br />
inX A [in[X’ A]A]</p>
<ul>
<li><p>Gère l’ordre de décomposition <em>impensable/ADJ</em> = <em>in</em> + <em>pensable/ADJ</em><br />
<em>décomposable/ADJ</em> = <em>décomposer/VERBE</em> + <em>able/ADJ</em></p></li>
<li><p>Gère les analyses ambiguës<br />
<em>implantable/ADJ</em> = <em>implanter/VERBE</em> + <em>able/ADJ</em> ou bien <em>im</em> + <em>plantable/ADJ</em></p></li>
<li><p>Produit une « glose »<br />
(Prep lequel - Que l’) on peut implanter // Non</p></li>
</ul>
</section>
<section id="dérif" class="slide level3">
<h3>DériF</h3>
<p>Outil créé par Fiammetta Namer</p>
<p><a href="http://www.cnrtl.fr/outils/DeriF/">Version en ligne</a></p>
</section>
    </div>
  </div>

  <script src="files/reveal.js/lib/js/head.min.js"></script>
  <script src="files/reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: false,
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        maxScale: 1.2,
        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: 'files/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'files/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'files/reveal.js/plugin/math/math.js', async: true },
          { src: 'files/reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
